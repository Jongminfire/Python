# AND 연산 (&): 대응하는 숫자가 모두 1일 경우 1 반환

bin(0b1010011010 & 0b1101101100)  # 0b1000001000

# OR 연산 (|): 대응하는 숫자중 하나라도 1일 경우 1 반환

bin(0b1010011010 | 0b1101101100)  # 0b1111111110

# XOR 연산 (^): 대응하는 숫자가 서로 다를 경우 1 반환

bin(0b1010011010 ^ 0b1101101100)  # 0b111110110

# SHIFT 연산 (>>,<<) : a << b 는 a 비트를 b칸 만큼 왼쪽으로 밀어 내고, a >> b는 a 비트를 b칸 만큼 오른쪽으로 밀어냄

bin(0b0010 << 2)  # 0b1000
bin(0b1100 >> 2)  # 0b11

# NOT 연산 (~) : 비트 값을 반전 시킴

bin(~0b0010 << 2)  # 0b1101

# 원소 추가 : n번째 수를 추가 할 떄

n = 3
A = 0b0010
A |= 1 << n  # bin(A) = 0b1010

# 원소 제거 : n번째 수를 제거 하고자 할 때

n = 3
A = 0b1010
A &= 1 << n # bin(A) = 0b1000

# 원소 조회 : n번째 수가 있나 없나 확인 (0이면 없고, 1이상이면 있음)

A = 0b1010
print(A & (1<<3))   # 8
print(A & (1<<0))   # 0

# 원소 토글: n번째 수가 켜져 있으면 끄고, 꺼져 있으면 킴

A = 0b1010
A ^= (1 << 2)  #  bin(A) -> 0b1110
